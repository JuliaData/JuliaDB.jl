<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · JuliaDB.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuliaDB.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Overview</a></li><li><a class="toctext" href="../basics/">Basics</a></li><li><a class="toctext" href="../operations/">Table Operations</a></li><li><a class="toctext" href="../joins/">Joins</a></li><li><a class="toctext" href="../onlinestats/">OnlineStats Integration</a></li><li><a class="toctext" href="../plotting/">Plotting</a></li><li><a class="toctext" href="../missing_values/">Missing Values</a></li><li><a class="toctext" href="../out_of_core/">Out-of-core processing</a></li><li><a class="toctext" href="../ml/">Feature Extraction</a></li><li><a class="toctext" href="../tutorial/">Tutorial</a></li><li class="current"><a class="toctext" href>API</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul><a class="edit-page" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><ul><li><a href="#IndexedTables.All"><code>IndexedTables.All</code></a></li><li><a href="#IndexedTables.Between"><code>IndexedTables.Between</code></a></li><li><a href="#IndexedTables.ColDict-Tuple{Any}"><code>IndexedTables.ColDict</code></a></li><li><a href="#IndexedTables.IndexedTable"><code>IndexedTables.IndexedTable</code></a></li><li><a href="#IndexedTables.Keys"><code>IndexedTables.Keys</code></a></li><li><a href="#IndexedTables.NDSparse-Tuple"><code>IndexedTables.NDSparse</code></a></li><li><a href="#IndexedTables.Not"><code>IndexedTables.Not</code></a></li><li><a href="#IndexedTables.Perm"><code>IndexedTables.Perm</code></a></li><li><a href="#JuliaDB.DIndexedTable"><code>JuliaDB.DIndexedTable</code></a></li><li><a href="#JuliaDB.DNDSparse"><code>JuliaDB.DNDSparse</code></a></li><li><a href="#JuliaDB.IndexSpace"><code>JuliaDB.IndexSpace</code></a></li><li><a href="#JuliaDB.Interval"><code>JuliaDB.Interval</code></a></li><li><a href="#Base.Broadcast.broadcast-Tuple{Function,NDSparse,NDSparse}"><code>Base.Broadcast.broadcast</code></a></li><li><a href="#Base.collect-Tuple{JuliaDB.DNDSparse}"><code>Base.collect</code></a></li><li><a href="#Base.convert-Tuple{Type{IndexedTable},Any,Any}"><code>Base.convert</code></a></li><li><a href="#Base.filter-Tuple{Any,Union{IndexedTable, NDSparse}}"><code>Base.filter</code></a></li><li><a href="#Base.getindex-Union{Tuple{K}, Tuple{DNDSparse{K,V} where V,Vararg{Any,N} where N}} where K"><code>Base.getindex</code></a></li><li><a href="#Base.join-Tuple{Any,Union{IndexedTable, NDSparse},Union{IndexedTable, NDSparse}}"><code>Base.join</code></a></li><li><a href="#Base.keys-Tuple{NDSparse,Vararg{Any,N} where N}"><code>Base.keys</code></a></li><li><a href="#Base.length-Tuple{JuliaDB.DNDSparse}"><code>Base.length</code></a></li><li><a href="#Base.map-Tuple{Any,NDSparse}"><code>Base.map</code></a></li><li><a href="#Base.map-Tuple{Any,IndexedTables.AbstractIndexedTable}"><code>Base.map</code></a></li><li><a href="#Base.map-Tuple{Any,JuliaDB.DNDSparse}"><code>Base.map</code></a></li><li><a href="#Base.merge-Tuple{Union{IndexedTable, NDSparse},Any}"><code>Base.merge</code></a></li><li><a href="#Base.pairs-Union{Tuple{N}, Tuple{NDSparse,Vararg{Any,N}}} where N"><code>Base.pairs</code></a></li><li><a href="#Base.reduce-Tuple{Any,IndexedTable}"><code>Base.reduce</code></a></li><li><a href="#Base.reduce-Tuple{Any,NDSparse}"><code>Base.reduce</code></a></li><li><a href="#Base.sort-Tuple{IndexedTable,Vararg{Any,N} where N}"><code>Base.sort</code></a></li><li><a href="#Base.sort!-Tuple{IndexedTable,Vararg{Any,N} where N}"><code>Base.sort!</code></a></li><li><a href="#Base.values-Tuple{NDSparse,Vararg{Any,N} where N}"><code>Base.values</code></a></li><li><a href="#Dagger.compute-Tuple{JuliaDB.DNDSparse}"><code>Dagger.compute</code></a></li><li><a href="#Dagger.distribute"><code>Dagger.distribute</code></a></li><li><a href="#Dagger.distribute-Union{Tuple{V}, Tuple{NDSparse{V,D,C,V1} where V1&lt;:(AbstractArray{T,1} where T) where C&lt;:(StructArray{T,1,C} where C&lt;:NamedTuple where T) where D&lt;:Tuple,AbstractArray}} where V"><code>Dagger.distribute</code></a></li><li><a href="#Dagger.distribute-Tuple{IndexedTable,Any}"><code>Dagger.distribute</code></a></li><li><a href="#Dagger.load-Tuple{AbstractString}"><code>Dagger.load</code></a></li><li><a href="#Dagger.save-Tuple{Union{IndexedTable, NDSparse},AbstractString}"><code>Dagger.save</code></a></li><li><a href="#Dagger.save-Tuple{Union{DIndexedTable, DNDSparse},AbstractString}"><code>Dagger.save</code></a></li><li><a href="#IndexedTables.aggregate!-Tuple{Any,NDSparse}"><code>IndexedTables.aggregate!</code></a></li><li><a href="#IndexedTables.arrayof-Tuple{Any}"><code>IndexedTables.arrayof</code></a></li><li><a href="#IndexedTables.asofjoin-Tuple{NDSparse,NDSparse}"><code>IndexedTables.asofjoin</code></a></li><li><a href="#IndexedTables.best_perm_estimate-Tuple{Any,Any}"><code>IndexedTables.best_perm_estimate</code></a></li><li><a href="#IndexedTables.collect_columns-Tuple"><code>IndexedTables.collect_columns</code></a></li><li><a href="#IndexedTables.colnames"><code>IndexedTables.colnames</code></a></li><li><a href="#IndexedTables.columns-Tuple{Any,Any}"><code>IndexedTables.columns</code></a></li><li><a href="#IndexedTables.columns"><code>IndexedTables.columns</code></a></li><li><a href="#IndexedTables.convertdim-Tuple{NDSparse,Union{Int64, Symbol},Any}"><code>IndexedTables.convertdim</code></a></li><li><a href="#IndexedTables.convertdim-Union{Tuple{V}, Tuple{K}, Tuple{DNDSparse{K,V},Union{Int64, Symbol},Any}} where V where K"><code>IndexedTables.convertdim</code></a></li><li><a href="#IndexedTables.convertmissing-Tuple{IndexedTable,Type{Missing}}"><code>IndexedTables.convertmissing</code></a></li><li><a href="#IndexedTables.dimlabels-Tuple{NDSparse}"><code>IndexedTables.dimlabels</code></a></li><li><a href="#IndexedTables.dropmissing"><code>IndexedTables.dropmissing</code></a></li><li><a href="#IndexedTables.excludecols-Tuple{Any,Any}"><code>IndexedTables.excludecols</code></a></li><li><a href="#IndexedTables.flatten"><code>IndexedTables.flatten</code></a></li><li><a href="#IndexedTables.flush!-Tuple{NDSparse}"><code>IndexedTables.flush!</code></a></li><li><a href="#IndexedTables.groupby"><code>IndexedTables.groupby</code></a></li><li><a href="#IndexedTables.groupjoin-Tuple{Union{IndexedTable, NDSparse},Union{IndexedTable, NDSparse}}"><code>IndexedTables.groupjoin</code></a></li><li><a href="#IndexedTables.groupreduce"><code>IndexedTables.groupreduce</code></a></li><li><a href="#IndexedTables.insertcol-Tuple{Any,Integer,Any,Any}"><code>IndexedTables.insertcol</code></a></li><li><a href="#IndexedTables.insertcolafter-NTuple{4,Any}"><code>IndexedTables.insertcolafter</code></a></li><li><a href="#IndexedTables.insertcolbefore-NTuple{4,Any}"><code>IndexedTables.insertcolbefore</code></a></li><li><a href="#IndexedTables.leftjoin-Union{Tuple{V}, Tuple{K}, Tuple{Any,DNDSparse{K,V},DNDSparse}, Tuple{Any,DNDSparse{K,V},DNDSparse,Any}, Tuple{Any,DNDSparse{K,V},DNDSparse,Any,Any}} where V where K"><code>IndexedTables.leftjoin</code></a></li><li><a href="#IndexedTables.map_rows-Tuple{Any,Vararg{Any,N} where N}"><code>IndexedTables.map_rows</code></a></li><li><a href="#IndexedTables.naturaljoin-Union{Tuple{D2}, Tuple{D1}, Tuple{J}, Tuple{I}, Tuple{DNDSparse{I,D1},DNDSparse{J,D2}}} where D2 where D1 where J where I"><code>IndexedTables.naturaljoin</code></a></li><li><a href="#IndexedTables.naturaljoin-Tuple{Any,JuliaDB.DNDSparse,JuliaDB.DNDSparse}"><code>IndexedTables.naturaljoin</code></a></li><li><a href="#IndexedTables.ncols"><code>IndexedTables.ncols</code></a></li><li><a href="#IndexedTables.ndsparse"><code>IndexedTables.ndsparse</code></a></li><li><a href="#IndexedTables.pkeynames-Tuple{NDSparse}"><code>IndexedTables.pkeynames</code></a></li><li><a href="#IndexedTables.pkeynames-Tuple{IndexedTables.AbstractIndexedTable}"><code>IndexedTables.pkeynames</code></a></li><li><a href="#IndexedTables.pkeys-Tuple{IndexedTable}"><code>IndexedTables.pkeys</code></a></li><li><a href="#IndexedTables.popcol-Tuple{Any,Vararg{Any,N} where N}"><code>IndexedTables.popcol</code></a></li><li><a href="#IndexedTables.pushcol-Tuple{Any,Vararg{Any,N} where N}"><code>IndexedTables.pushcol</code></a></li><li><a href="#IndexedTables.reducedim_vec-Tuple{Any,NDSparse,Any}"><code>IndexedTables.reducedim_vec</code></a></li><li><a href="#IndexedTables.reducedim_vec-Tuple{Any,JuliaDB.DNDSparse,Any}"><code>IndexedTables.reducedim_vec</code></a></li><li><a href="#IndexedTables.reindex"><code>IndexedTables.reindex</code></a></li><li><a href="#IndexedTables.renamecol-Tuple{Any,Vararg{Any,N} where N}"><code>IndexedTables.renamecol</code></a></li><li><a href="#IndexedTables.rows"><code>IndexedTables.rows</code></a></li><li><a href="#IndexedTables.select-Tuple{IndexedTables.AbstractIndexedTable,Any}"><code>IndexedTables.select</code></a></li><li><a href="#IndexedTables.selectkeys-Tuple{NDSparse,Any}"><code>IndexedTables.selectkeys</code></a></li><li><a href="#IndexedTables.selectvalues-Tuple{NDSparse,Any}"><code>IndexedTables.selectvalues</code></a></li><li><a href="#IndexedTables.setcol-Tuple{Any,Vararg{Any,N} where N}"><code>IndexedTables.setcol</code></a></li><li><a href="#IndexedTables.stack-Union{Tuple{D}, Tuple{D}, Tuple{D,Any}} where D&lt;:Union{IndexedTable, NDSparse}"><code>IndexedTables.stack</code></a></li><li><a href="#IndexedTables.summarize"><code>IndexedTables.summarize</code></a></li><li><a href="#IndexedTables.table"><code>IndexedTables.table</code></a></li><li><a href="#IndexedTables.unstack-Union{Tuple{D}, Tuple{D}, Tuple{D,Any}} where D&lt;:Union{IndexedTable, NDSparse}"><code>IndexedTables.unstack</code></a></li><li><a href="#IndexedTables.update!-Union{Tuple{N}, Tuple{Union{Function, Type},NDSparse,Vararg{Any,N}}} where N"><code>IndexedTables.update!</code></a></li><li><a href="#IndexedTables.where-Union{Tuple{N}, Tuple{NDSparse,Vararg{Any,N}}} where N"><code>IndexedTables.where</code></a></li><li><a href="#JuliaDB.fromchunks-Tuple{AbstractArray,Vararg{Any,N} where N}"><code>JuliaDB.fromchunks</code></a></li><li><a href="#JuliaDB.loadndsparse-Tuple{Union{String, AbstractArray{T,1} where T}}"><code>JuliaDB.loadndsparse</code></a></li><li><a href="#JuliaDB.loadtable-Tuple{Union{String, AbstractArray{T,1} where T}}"><code>JuliaDB.loadtable</code></a></li><li><a href="#JuliaDB.mapchunks-Union{Tuple{V}, Tuple{K}, Tuple{Any,DNDSparse{K,V}}} where V where K"><code>JuliaDB.mapchunks</code></a></li><li><a href="#JuliaDB.partitionplot"><code>JuliaDB.partitionplot</code></a></li><li><a href="#JuliaDB.rechunk"><code>JuliaDB.rechunk</code></a></li><li><a href="#JuliaDB.tracktime-Tuple{Any}"><code>JuliaDB.tracktime</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.compute-Tuple{JuliaDB.DNDSparse}" href="#Dagger.compute-Tuple{JuliaDB.DNDSparse}"><code>Dagger.compute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">compute(t::DNDSparse; allowoverlap, closed)</code></pre><p>Computes any delayed-evaluations in the <code>DNDSparse</code>. The computed data is left on the worker processes. Subsequent operations on the results will reuse the chunks.</p><p>If <code>allowoverlap</code> is false then the computed data is re-sorted if required to have no chunks with overlapping index ranges if necessary.</p><p>If <code>closed</code> is true then the computed data is re-sorted if required to have no chunks with overlapping OR continuous boundaries.</p><p>See also <a href="#Base.collect-Tuple{JuliaDB.DNDSparse}"><code>collect</code></a>.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>compute(t)</code> requires at least as much memory as the size of the result of the computing <code>t</code>. You usually don&#39;t need to do this for the whole dataset. If the result is expected to be big, try <code>compute(save(t, &quot;output_dir&quot;))</code> instead. See <a href="#Dagger.save-Tuple{Union{DIndexedTable, DNDSparse},AbstractString}"><code>save</code></a> for more.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/ndsparse.jl#L112-L132">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.distribute" href="#Dagger.distribute"><code>Dagger.distribute</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">distribute(itable::NDSparse, nchunks::Int=nworkers())</code></pre><p>Distributes an NDSparse object into a DNDSparse of <code>nchunks</code> chunks of approximately equal size.</p><p>Returns a <code>DNDSparse</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/ndsparse.jl#L459-L466">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.distribute-Tuple{IndexedTable,Any}" href="#Dagger.distribute-Tuple{IndexedTable,Any}"><code>Dagger.distribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">distribute(t::Table, chunks)</code></pre><p>Distribute a table in <code>chunks</code> pieces. Equivalent to <code>table(t, chunks=chunks)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/table.jl#L185-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.distribute-Union{Tuple{V}, Tuple{NDSparse{V,D,C,V1} where V1&lt;:(AbstractArray{T,1} where T) where C&lt;:(StructArray{T,1,C} where C&lt;:NamedTuple where T) where D&lt;:Tuple,AbstractArray}} where V" href="#Dagger.distribute-Union{Tuple{V}, Tuple{NDSparse{V,D,C,V1} where V1&lt;:(AbstractArray{T,1} where T) where C&lt;:(StructArray{T,1,C} where C&lt;:NamedTuple where T) where D&lt;:Tuple,AbstractArray}} where V"><code>Dagger.distribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">distribute(itable::NDSparse, rowgroups::AbstractArray)</code></pre><p>Distributes an NDSparse object into a DNDSparse by splitting it up into chunks of <code>rowgroups</code> elements. <code>rowgroups</code> is a vector specifying the number of rows in the chunks.</p><p>Returns a <code>DNDSparse</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/ndsparse.jl#L428-L436">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.load-Tuple{AbstractString}" href="#Dagger.load-Tuple{AbstractString}"><code>Dagger.load</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>load(dir::AbstractString)</code></p><p>Load a saved <code>DNDSparse</code> from <code>dir</code> directory. Data can be saved using the <code>save</code> function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/io.jl#L167-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.save-Tuple{Union{DIndexedTable, DNDSparse},AbstractString}" href="#Dagger.save-Tuple{Union{DIndexedTable, DNDSparse},AbstractString}"><code>Dagger.save</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">save(t::Union{DNDSparse, DIndexedTable}, destdir::AbstractString)</code></pre><p>Saves a distributed dataset to disk in directory <code>destdir</code>. Saved data can be loaded with <a href="#Dagger.load-Tuple{AbstractString}"><code>load</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/io.jl#L188-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.save-Tuple{Union{IndexedTable, NDSparse},AbstractString}" href="#Dagger.save-Tuple{Union{IndexedTable, NDSparse},AbstractString}"><code>Dagger.save</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">save(t::Union{NDSparse, IndexedTable}, dest::AbstractString)</code></pre><p>Save a dataset to disk as <code>dest</code>.  Saved data can be loaded with <a href="#Dagger.load-Tuple{AbstractString}"><code>load</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/io.jl#L206-L210">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.convertdim-Union{Tuple{V}, Tuple{K}, Tuple{DNDSparse{K,V},Union{Int64, Symbol},Any}} where V where K" href="#IndexedTables.convertdim-Union{Tuple{V}, Tuple{K}, Tuple{DNDSparse{K,V},Union{Int64, Symbol},Any}} where V where K"><code>IndexedTables.convertdim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convertdim(x::DNDSparse, d::DimName, xlate; agg::Function, name)</code></pre><p>Apply function or dictionary <code>xlate</code> to each index in the specified dimension. If the mapping is many-to-one, <code>agg</code> is used to aggregate the results. <code>name</code> optionally specifies a name for the new dimension. <code>xlate</code> must be a monotonically increasing function.</p><p>See also <a href="#Base.reduce-Tuple{Any,IndexedTable}"><code>reduce</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/selection.jl#L36-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.leftjoin-Union{Tuple{V}, Tuple{K}, Tuple{Any,DNDSparse{K,V},DNDSparse}, Tuple{Any,DNDSparse{K,V},DNDSparse,Any}, Tuple{Any,DNDSparse{K,V},DNDSparse,Any,Any}} where V where K" href="#IndexedTables.leftjoin-Union{Tuple{V}, Tuple{K}, Tuple{Any,DNDSparse{K,V},DNDSparse}, Tuple{Any,DNDSparse{K,V},DNDSparse,Any}, Tuple{Any,DNDSparse{K,V},DNDSparse,Any,Any}} where V where K"><code>IndexedTables.leftjoin</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">leftjoin(left::DNDSparse, right::DNDSparse, [op::Function])</code></pre><p>Keeps only rows with indices in <code>left</code>. If rows of the same index are present in <code>right</code>, then they are combined using <code>op</code>. <code>op</code> by default picks the value from <code>right</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/join.jl#L194-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.naturaljoin-Tuple{Any,JuliaDB.DNDSparse,JuliaDB.DNDSparse}" href="#IndexedTables.naturaljoin-Tuple{Any,JuliaDB.DNDSparse,JuliaDB.DNDSparse}"><code>IndexedTables.naturaljoin</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">naturaljoin(op, left::DNDSparse, right::DNDSparse, ascolumns=false)</code></pre><p>Returns a new <code>DNDSparse</code> containing only rows where the indices are present both in <code>left</code> AND <code>right</code> tables. The data columns are concatenated. The data of the matching rows from <code>left</code> and <code>right</code> are combined using <code>op</code>. If <code>op</code> returns a tuple or NamedTuple, and <code>ascolumns</code> is set to true, the output table will contain the tuple elements as separate data columns instead as a single column of resultant tuples.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/join.jl#L148-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.naturaljoin-Union{Tuple{D2}, Tuple{D1}, Tuple{J}, Tuple{I}, Tuple{DNDSparse{I,D1},DNDSparse{J,D2}}} where D2 where D1 where J where I" href="#IndexedTables.naturaljoin-Union{Tuple{D2}, Tuple{D1}, Tuple{J}, Tuple{I}, Tuple{DNDSparse{I,D1},DNDSparse{J,D2}}} where D2 where D1 where J where I"><code>IndexedTables.naturaljoin</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">naturaljoin(left::DNDSparse, right::DNDSparse, [op])</code></pre><p>Returns a new <code>DNDSparse</code> containing only rows where the indices are present both in <code>left</code> AND <code>right</code> tables. The data columns are concatenated.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/join.jl#L138-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.reducedim_vec-Tuple{Any,JuliaDB.DNDSparse,Any}" href="#IndexedTables.reducedim_vec-Tuple{Any,JuliaDB.DNDSparse,Any}"><code>IndexedTables.reducedim_vec</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">reducedim_vec(f::Function, t::DNDSparse, dims)</code></pre><p>Like <code>reducedim</code>, except uses a function mapping a vector of values to a scalar instead of a 2-argument scalar function.</p><p>See also <a href="@ref"><code>reducedim</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/reduce.jl#L117-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.loadndsparse-Tuple{Union{String, AbstractArray{T,1} where T}}" href="#JuliaDB.loadndsparse-Tuple{Union{String, AbstractArray{T,1} where T}}"><code>JuliaDB.loadndsparse</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>loadndsparse(files::Union{AbstractVector,String}; &lt;options&gt;)</code></p><p>Load an <a href="@ref">NDSparse</a> from CSV files.</p><p><code>files</code> is either a vector of file paths, or a directory name.</p><p><strong>Options:</strong></p><ul><li><code>indexcols::Vector</code> – columns to use as indexed columns. (by default a <code>1:n</code> implicit index is used.)</li><li><code>datacols::Vector</code> – non-indexed columns. (defaults to all columns but indexed columns). Specify this to only load a subset of columns. In place of the name of a column, you can specify a tuple of names – this will treat any column with one of those names as the same column, but use the first name in the tuple. This is useful when the same column changes name between CSV files. (e.g. <code>vendor_id</code> and <code>VendorId</code>)</li></ul><p>All other options are identical to those in <a href="#JuliaDB.loadtable-Tuple{Union{String, AbstractArray{T,1} where T}}"><code>loadtable</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/io.jl#L66-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.loadtable-Tuple{Union{String, AbstractArray{T,1} where T}}" href="#JuliaDB.loadtable-Tuple{Union{String, AbstractArray{T,1} where T}}"><code>JuliaDB.loadtable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>loadtable(files::Union{AbstractVector,String}; &lt;options&gt;)</code></p><p>Load a <a href="@ref Table">table</a> from CSV files.</p><p><code>files</code> is either a vector of file paths, or a directory name.</p><p><strong>Options:</strong></p><ul><li><p><code>output::AbstractString</code> – directory name to write the table to. By default data is loaded directly to memory. Specifying this option will allow you to load data larger than the available memory.</p></li><li><p><code>indexcols::Vector</code> – columns to use as primary key columns. (defaults to [])</p></li><li><p><code>datacols::Vector</code> – non-indexed columns. (defaults to all columns but indexed columns). Specify this to only load a subset of columns. In place of the name of a column, you can specify a tuple of names – this will treat any column with one of those names as the same column, but use the first name in the tuple. This is useful when the same column changes name between CSV files. (e.g. <code>vendor_id</code> and <code>VendorId</code>)</p></li><li><p><code>distributed::Bool</code> – should the output dataset be loaded as a distributed table? If true, this will use all available worker processes to load the data. (defaults to true if workers are available, false if not)</p></li><li><p><code>chunks::Int</code> – number of chunks to create when loading distributed. (defaults to number of workers)</p></li><li><p><code>delim::Char</code> – the delimiter character. (defaults to <code>,</code>). Use <code>spacedelim=true</code> to split by spaces.</p></li><li><p><code>spacedelim::Bool</code>: parse space-delimited files. <code>delim</code> has no effect if true.</p></li><li><p><code>quotechar::Char</code> – quote character. (defaults to <code>&quot;</code>)</p></li><li><p><code>escapechar::Char</code> – escape character. (defaults to <code>&quot;</code>)</p></li><li><p><code>filenamecol::Union{Symbol, Pair}</code> – create a column containing the file names from where each row came from. This argument gives a name to the column. By default, <code>basename(name)</code> of the name is kept, and &quot;.csv&quot; suffix will be stripped. To provide a custom function to apply on the names, use a <code>name =&gt; Function</code> pair. By default, no file name column will be created.</p></li><li><p><code>header_exists::Bool</code> – does header exist in the files? (defaults to true)</p></li><li><p><code>colnames::Vector{String}</code> – specify column names for the files, use this with (<code>header_exists=false</code>, otherwise first row is discarded). By default column names are assumed to be present in the file.</p></li><li><p><code>samecols</code> – a vector of tuples of strings where each tuple contains alternative names for the same column. For example, if some files have the name &quot;vendor<em>id&quot; and others have the name &quot;VendorID&quot;, pass `samecols=[(&quot;VendorID&quot;, &quot;vendor</em>id&quot;)]`.</p></li><li><p><code>colparsers</code> – either a vector or dictionary of data types or an <a href="https://juliacomputing.com/TextParse.jl/stable/#Available-AbstractToken-types-1"><code>AbstractToken</code> object</a> from <a href="https://juliacomputing.com/TextParse.jl/stable">TextParse</a> package. By default, these are inferred automatically. See <code>type_detect_rows</code> option below.</p></li><li><p><code>type_detect_rows</code>: number of rows to use to infer the initial <code>colparsers</code> defaults to 20.</p></li><li><p><code>nastrings::Vector{String}</code> – strings that are to be considered missing values. (defaults to <code>TextParse.NA_STRINGS</code>)</p></li><li><p><code>skiplines_begin::Char</code> – skip some lines in the beginning of each file. (doesn&#39;t skip by default)</p></li><li><p><code>usecache::Bool</code>: (vestigial)</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/io.jl#L33-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.partitionplot" href="#JuliaDB.partitionplot"><code>JuliaDB.partitionplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">partitionplot(table, y;    stat=Extrema(), nparts=100, by=nothing, dropmissing=false)
partitionplot(table, x, y; stat=Extrema(), nparts=100, by=nothing, dropmissing=false)</code></pre><p>Plot a summary of variable <code>y</code> against <code>x</code> (<code>1:length(y)</code> if not specified).  Using <code>nparts</code> approximately-equal sections along the x-axis, the data in <code>y</code> over each section is  summarized by <code>stat</code>. </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/recipes.jl#L32-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.rechunk" href="#JuliaDB.rechunk"><code>JuliaDB.rechunk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>rechunk(t::Union{DNDSparse, DNDSparse}[, by[, select]]; &lt;options&gt;)</code></p><p>Reindex and sort a distributed dataset by keys selected by <code>by</code>.</p><p>Optionally <code>select</code> specifies which non-indexed fields are kept. By default this is all fields not mentioned in <code>by</code> for Table and the value columns for NDSparse.</p><p><strong>Options:</strong></p><ul><li><code>chunks</code> – how to distribute the data. This can be:<ol><li>An integer – number of chunks to create</li><li>An vector of <code>k</code> integers – number of elements in each of the <code>k</code> chunks. <code>sum(k)</code> must be same as <code>length(t)</code></li><li>The distribution of another array. i.e. <code>vec.subdomains</code> where <code>vec</code> is a distributed array.</li></ol></li><li><code>merge::Function</code> – a function which merges two sub-table or sub-ndsparse into one NDSparse. They may have overlaps in their indices.</li><li><code>splitters::AbstractVector</code> – specify keys to split by. To create <code>n</code> chunks you would need to pass <code>n-1</code> splitters and also the <code>chunks=n</code> option.</li><li><code>chunks_sorted::Bool</code> – are the chunks sorted locally? If true, this skips sorting or re-indexing them.</li><li><code>affinities::Vector{&lt;:Integer}</code> – which processes (Int pid) should each output chunk be created on. If unspecified all workers are used.</li><li><code>closed::Bool</code> – if true, the same key will not be present in multiple chunks (although sorted). <code>true</code> by default.</li><li><code>nsamples::Integer</code> – number of keys to randomly sample from each chunk to estimate splitters in the sorting process. (See <a href="https://en.wikipedia.org/wiki/Samplesort">samplesort</a>). Defaults to 2000.</li><li><code>batchsize::Integer</code> – how many chunks at a time from the input should be loaded into memory at any given time. This will essentially sort in batches of <code>batchsize</code> chunks.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/sort.jl#L8-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.tracktime-Tuple{Any}" href="#JuliaDB.tracktime-Tuple{Any}"><code>JuliaDB.tracktime</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>tracktime(f)</code></p><p>Track the time spent on different processes in different categories in running <code>f</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/diagnostics.jl#L83-L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.DIndexedTable" href="#JuliaDB.DIndexedTable"><code>JuliaDB.DIndexedTable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A distributed table</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/table.jl#L18-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.DNDSparse" href="#JuliaDB.DNDSparse"><code>JuliaDB.DNDSparse</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DNDSparse{K,V} &lt;: AbstractNDSparse</code></pre><p>A distributed <a href="@ref">NDSparse</a> datastructure. Can be constructed by:</p><ul><li><a href="#IndexedTables.ndsparse"><code>ndsparse</code></a> from Julia objects</li><li><a href="#JuliaDB.loadndsparse-Tuple{Union{String, AbstractArray{T,1} where T}}"><code>loadndsparse</code></a> from data on disk</li><li><a href="#Dagger.distribute"><code>distribute</code></a> from an <a href="#IndexedTables.NDSparse-Tuple"><code>NDSparse</code></a> object</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/ndsparse.jl#L4-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.IndexSpace" href="#JuliaDB.IndexSpace"><code>JuliaDB.IndexSpace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IndexSpace(interval, boundingrect, nrows)</code></pre><p>Metadata about an chunk.</p><ul><li><code>interval</code>: An <code>Interval</code> object with the first and the last index tuples.</li><li><code>boundingrect</code>: An <code>Interval</code> object with the lowest and the highest indices as tuples.</li><li><code>nrows</code>: A <code>Nullable{Int}</code> of number of rows in the NDSparse, if knowable.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/table.jl#L3-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.Interval" href="#JuliaDB.Interval"><code>JuliaDB.Interval</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An interval type tailored specifically to store intervals of indices of an NDSparse object. Some of the operations on this like <code>in</code> or <code>&lt;</code> may be controversial for a generic Interval type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/interval.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.collect-Tuple{JuliaDB.DNDSparse}" href="#Base.collect-Tuple{JuliaDB.DNDSparse}"><code>Base.collect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">collect(t::DNDSparse)</code></pre><p>Gets distributed data in a DNDSparse <code>t</code> and merges it into <a href="#IndexedTables.NDSparse">NDSparse</a> object</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>collect(t)</code> requires at least as much memory as the size of the result of the computing <code>t</code>. If the result is expected to be big, try <code>compute(save(t, &quot;output_dir&quot;))</code> instead. See <a href="#Dagger.save-Tuple{Union{DIndexedTable, DNDSparse},AbstractString}"><code>save</code></a> for more. This data can be loaded later using <a href="#Dagger.load-Tuple{AbstractString}"><code>load</code></a>.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/ndsparse.jl#L150-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Union{Tuple{K}, Tuple{DNDSparse{K,V} where V,Vararg{Any,N} where N}} where K" href="#Base.getindex-Union{Tuple{K}, Tuple{DNDSparse{K,V} where V,Vararg{Any,N} where N}} where K"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">t[idx...]</code></pre><p>Returns a <code>DNDSparse</code> containing only the elements of <code>t</code> where the given indices (<code>idx</code>) match. If <code>idx</code> has the same type as the index tuple of the <code>t</code>, then this is considered a scalar indexing (indexing of a single value). In this case the value itself is looked up and returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/indexing.jl#L2-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length-Tuple{JuliaDB.DNDSparse}" href="#Base.length-Tuple{JuliaDB.DNDSparse}"><code>Base.length</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>The length of the <code>DNDSparse</code> if it can be computed. Will throw an error if not. You can get the length of such tables after calling <a href="#Dagger.compute-Tuple{JuliaDB.DNDSparse}"><code>compute</code></a> on them.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/ndsparse.jl#L302-L305">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map-Tuple{Any,JuliaDB.DNDSparse}" href="#Base.map-Tuple{Any,JuliaDB.DNDSparse}"><code>Base.map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">map(f, t::DNDSparse)</code></pre><p>Applies a function <code>f</code> on every element in the data of table <code>t</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/ndsparse.jl#L204-L208">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.fromchunks-Tuple{AbstractArray,Vararg{Any,N} where N}" href="#JuliaDB.fromchunks-Tuple{AbstractArray,Vararg{Any,N} where N}"><code>JuliaDB.fromchunks</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fromchunks(cs)</code></pre><p>Construct a distributed object from chunks. Calls <code>fromchunks(T, cs)</code> where T is the type of the data in the first chunk. Computes any thunks.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/table.jl#L122-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.mapchunks-Union{Tuple{V}, Tuple{K}, Tuple{Any,DNDSparse{K,V}}} where V where K" href="#JuliaDB.mapchunks-Union{Tuple{V}, Tuple{K}, Tuple{Any,DNDSparse{K,V}}} where V where K"><code>JuliaDB.mapchunks</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">mapchunks(f, t::DNDSparse; keeplengths=true)</code></pre><p>Applies a function to each chunk in <code>t</code>. Returns a new DNDSparse. If <code>keeplength</code> is false, this means that the lengths of the output chunks is unknown before <a href="#Dagger.compute-Tuple{JuliaDB.DNDSparse}"><code>compute</code></a>. This function is used internally by many DNDSparse operations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/87531c420820455c5b807caacee6637bc3a424a6/src/ndsparse.jl#L476-L483">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.All" href="#IndexedTables.All"><code>IndexedTables.All</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">All(cols::Union{Symbol, Int}...)</code></pre><p>Select the union of the selections in <code>cols</code>. If <code>cols == ()</code>, select all columns.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,1,2,2], [1,2,1,2], [1,2,3,4], [0, 0, 0, 0], names=[:a,:b,:c,:d])
select(t, All(:a, (:b, :c)))
select(t, All())</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.Between" href="#IndexedTables.Between"><code>IndexedTables.Between</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Between(first, last)</code></pre><p>Select the columns between <code>first</code> and <code>last</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,1,2,2], [1,2,1,2], 1:4, &#39;a&#39;:&#39;d&#39;, names=[:a,:b,:c,:d])
select(t, Between(:b, :d))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.ColDict-Tuple{Any}" href="#IndexedTables.ColDict-Tuple{Any}"><code>IndexedTables.ColDict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">d = ColDict(t)</code></pre><p>Create a mutable dictionary of columns in <code>t</code>.</p><p>To get the immutable iterator of the same type as <code>t</code> call <code>d[]</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.IndexedTable" href="#IndexedTables.IndexedTable"><code>IndexedTables.IndexedTable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A tabular data structure that extends <a href="@ref"><code>Columns</code></a>.  Create an <code>IndexedTable</code> with the <a href="#IndexedTables.table"><code>table</code></a> function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.Keys" href="#IndexedTables.Keys"><code>IndexedTables.Keys</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Keys()</code></pre><p>Select the primary keys.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,1,2,2], [1,2,1,2], [1,2,3,4], names=[:a,:b,:c], pkey = (:a, :b))
select(t, Keys())</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.NDSparse-Tuple" href="#IndexedTables.NDSparse-Tuple"><code>IndexedTables.NDSparse</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>NDSparse(columns...; names=Symbol[...], kwargs...)</code></p><p>Construct an NDSparse array from columns. The last argument is the data column, and the rest are index columns. The <code>names</code> keyword argument optionally specifies names for the index columns (dimensions).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.Not" href="#IndexedTables.Not"><code>IndexedTables.Not</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Not(cols::Union{Symbol, Int}...)</code></pre><p>Select the complementary of the selection in <code>cols</code>. <code>Not</code> can accept several arguments, in which case it returns the complementary of the union of the selections.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,1,2,2], [1,2,1,2], [1,2,3,4], names=[:a,:b,:c], pkey = (:a, :b))
select(t, Not(:a))
select(t, Not(:a, (:a, :b)))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.aggregate!-Tuple{Any,NDSparse}" href="#IndexedTables.aggregate!-Tuple{Any,NDSparse}"><code>IndexedTables.aggregate!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">aggregate!(f::Function, arr::NDSparse)</code></pre><p>Combine adjacent rows with equal indices using the given 2-argument reduction function, in place.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.asofjoin-Tuple{NDSparse,NDSparse}" href="#IndexedTables.asofjoin-Tuple{NDSparse,NDSparse}"><code>IndexedTables.asofjoin</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">asofjoin(left::NDSparse, right::NDSparse)</code></pre><p>Join rows from <code>left</code> with the &quot;most recent&quot; value from <code>right</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">using Dates
akey1 = [&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;]
akey2 = [Date(2017,11,11), Date(2017,11,12), Date(2017,11,11), Date(2017,11,12)]
avals = collect(1:4)

bkey1 = [&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;]
bkey2 = [Date(2017,11,12), Date(2017,11,13), Date(2017,11,10), Date(2017,11,13)]
bvals = collect(5:8)

a = ndsparse((akey1, akey2), avals)
b = ndsparse((bkey1, bkey2), bvals)

asofjoin(a, b)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.collect_columns-Tuple" href="#IndexedTables.collect_columns-Tuple"><code>IndexedTables.collect_columns</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">collect_columns(itr)</code></pre><p>Collect an iterable as a <code>Columns</code> object if it iterates <code>Tuples</code> or <code>NamedTuples</code>, as a normal <code>Array</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-none">s = [(1,2), (3,4)]
collect_columns(s)

s2 = Iterators.filter(isodd, 1:8)
collect_columns(s2)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.colnames" href="#IndexedTables.colnames"><code>IndexedTables.colnames</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">colnames(itr)</code></pre><p>Returns the names of the &quot;columns&quot; in <code>itr</code>.</p><p><strong>Examples:</strong></p><pre><code class="language-none">colnames(1:3)
colnames(Columns([1,2,3], [3,4,5]))
colnames(table([1,2,3], [3,4,5]))
colnames(Columns(x=[1,2,3], y=[3,4,5]))
colnames(table([1,2,3], [3,4,5], names=[:x,:y]))
colnames(ndsparse(Columns(x=[1,2,3]), Columns(y=[3,4,5])))
colnames(ndsparse(Columns(x=[1,2,3]), [3,4,5]))
colnames(ndsparse(Columns(x=[1,2,3]), [3,4,5]))
colnames(ndsparse(Columns([1,2,3], [4,5,6]), Columns(x=[6,7,8])))
colnames(ndsparse(Columns(x=[1,2,3]), Columns([3,4,5],[6,7,8])))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.columns" href="#IndexedTables.columns"><code>IndexedTables.columns</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">columns(itr, select::Selection = All())</code></pre><p>Select one or more columns from an iterable of rows as a tuple of vectors.</p><p><code>select</code> specifies which columns to select. Refer to the <a href="#IndexedTables.select-Tuple{IndexedTables.AbstractIndexedTable,Any}"><code>select</code></a> function for the available selection options and syntax.</p><p><code>itr</code> can be <code>NDSparse</code>, <code>Columns</code>, <code>AbstractVector</code>, or their distributed counterparts.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table(1:2, 3:4; names = [:x, :y])

columns(t)
columns(t, :x)
columns(t, (:x,))
columns(t, (:y, :x =&gt; -))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.columns-Tuple{Any,Any}" href="#IndexedTables.columns-Tuple{Any,Any}"><code>IndexedTables.columns</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>columns(itr, which)</code></p><p>Returns a vector or a tuple of vectors from the iterator.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.convertdim-Tuple{NDSparse,Union{Int64, Symbol},Any}" href="#IndexedTables.convertdim-Tuple{NDSparse,Union{Int64, Symbol},Any}"><code>IndexedTables.convertdim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>convertdim(x::NDSparse, d::DimName, xlate; agg::Function, vecagg::Function, name)</code></p><p>Apply function or dictionary <code>xlate</code> to each index in the specified dimension. If the mapping is many-to-one, <code>agg</code> or <code>vecagg</code> is used to aggregate the results. If <code>agg</code> is passed, it is used as a 2-argument reduction function over the data. If <code>vecagg</code> is passed, it is used as a vector-to-scalar function to aggregate the data. <code>name</code> optionally specifies a new name for the translated dimension.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.dimlabels-Tuple{NDSparse}" href="#IndexedTables.dimlabels-Tuple{NDSparse}"><code>IndexedTables.dimlabels</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>dimlabels(t::NDSparse)</code></p><p>Returns an array of integers or symbols giving the labels for the dimensions of <code>t</code>. <code>ndims(t) == length(dimlabels(t))</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.dropmissing" href="#IndexedTables.dropmissing"><code>IndexedTables.dropmissing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dropmissing(t        )
dropmissing(t, select)</code></pre><p>Drop rows of table <code>t</code> which contain missing values (either <code>Missing</code> or <code>DataValue</code>),  optionally only using the columns in <code>select</code>.  Column types will be converted to  non-missing types.  For example:</p><ul><li><code>Vector{Union{Int, Missing}}</code> -&gt; <code>Vector{Int}</code></li><li><code>DataValueArray{Int}</code> -&gt; Vector{Int}</li></ul><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.1,0.5,missing,0.7], [2,missing,4,5], [missing,6,missing,7], names=[:t,:x,:y])
dropmissing(t)
dropmissing(t, (:t, :x))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.flatten" href="#IndexedTables.flatten"><code>IndexedTables.flatten</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">flatten(t::Table, col=length(columns(t)))</code></pre><p>Flatten <code>col</code> column which may contain a vector of vectors while repeating the other fields. If column argument is not provided, default to last column.</p><p><strong>Examples:</strong></p><pre><code class="language-none">x = table([1,2], [[3,4], [5,6]], names=[:x, :y])
flatten(x, 2)

t1 = table([3,4],[5,6], names=[:a,:b])
t2 = table([7,8], [9,10], names=[:a,:b])
x = table([1,2], [t1, t2], names=[:x, :y]);
flatten(x, :y)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.flush!-Tuple{NDSparse}" href="#IndexedTables.flush!-Tuple{NDSparse}"><code>IndexedTables.flush!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>flush!(arr::NDSparse)</code></p><p>Commit queued assignment operations, by sorting and merging the internal temporary buffer.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.groupby" href="#IndexedTables.groupby"><code>IndexedTables.groupby</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">groupby(f, t, by = pkeynames(t); select, flatten=false)</code></pre><p>Apply <code>f</code> to the <code>select</code>-ed columns (see <a href="#IndexedTables.select-Tuple{IndexedTables.AbstractIndexedTable,Any}"><code>select</code></a>) in groups defined by the unique values of <code>by</code>.</p><p>If <code>f</code> returns a vector, split it into multiple columns with <code>flatten = true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using Statistics

t=table([1,1,1,2,2,2], [1,1,2,2,1,1], [1,2,3,4,5,6], names=[:x,:y,:z])

groupby(mean, t, :x, select=:z)
groupby(identity, t, (:x, :y), select=:z)
groupby(mean, t, (:x, :y), select=:z)

groupby((mean, std, var), t, :y, select=:z)
groupby((q25=z-&gt;quantile(z, 0.25), q50=median, q75=z-&gt;quantile(z, 0.75)), t, :y, select=:z)

# apply different aggregation functions to different columns
groupby((ymean = :y =&gt; mean, zmean = :z =&gt; mean), t, :x)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.groupjoin-Tuple{Union{IndexedTable, NDSparse},Union{IndexedTable, NDSparse}}" href="#IndexedTables.groupjoin-Tuple{Union{IndexedTable, NDSparse},Union{IndexedTable, NDSparse}}"><code>IndexedTables.groupjoin</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">groupjoin(left, right; kw...)
groupjoin(f, left, right; kw...)</code></pre><p>Join <code>left</code> and <code>right</code> creating groups of values with matching keys.</p><p>For keyword argument options, see <a href="#Base.join-Tuple{Any,Union{IndexedTable, NDSparse},Union{IndexedTable, NDSparse}}"><code>join</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">l = table([1,1,1,2], [1,2,2,1], [1,2,3,4], names=[:a,:b,:c], pkey=(:a, :b))
r = table([0,1,1,2], [1,2,2,1], [1,2,3,4], names=[:a,:b,:d], pkey=(:a, :b))

groupjoin(l, r)
groupjoin(l, r; how = :left)
groupjoin(l, r; how = :outer)
groupjoin(l, r; how = :anti)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.groupreduce" href="#IndexedTables.groupreduce"><code>IndexedTables.groupreduce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">groupreduce(f, t, by = pkeynames(t); select)</code></pre><p>Calculate a <a href="#Base.reduce-Tuple{Any,IndexedTable}"><code>reduce</code></a> operation <code>f</code> over table <code>t</code> on groups defined by the values in selection <code>by</code>.  The result is put in a table keyed by the unique <code>by</code> values.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,1,1,2,2,2], 1:6, names=[:x, :y])
groupreduce(+,        t, :x; select = :y)
groupreduce((sum=+,), t, :x; select = :y)  # change output column name to :sum

t2 = table([1,1,1,2,2,2], [1,1,2,2,3,3], 1:6, names = [:x, :y, :z])
groupreduce(+, t2, (:x, :y), select = :z)

# different reducers for different columns
groupreduce((sumy = :y =&gt; +, sumz = :z =&gt; +), t2, :x)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.insertcol-Tuple{Any,Integer,Any,Any}" href="#IndexedTables.insertcol-Tuple{Any,Integer,Any,Any}"><code>IndexedTables.insertcol</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">insertcol(t, position::Integer, name, x)</code></pre><p>Insert a column <code>x</code> named <code>name</code> at <code>position</code>. Returns a new table.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
insertcol(t, 2, :w, [0,1])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.insertcolafter-NTuple{4,Any}" href="#IndexedTables.insertcolafter-NTuple{4,Any}"><code>IndexedTables.insertcolafter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">insertcolafter(t, after, name, col)</code></pre><p>Insert a column <code>col</code> named <code>name</code> after <code>after</code>. Returns a new table.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
insertcolafter(t, :t, :w, [0,1])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.insertcolbefore-NTuple{4,Any}" href="#IndexedTables.insertcolbefore-NTuple{4,Any}"><code>IndexedTables.insertcolbefore</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">insertcolbefore(t, before, name, col)</code></pre><p>Insert a column <code>col</code> named <code>name</code> before <code>before</code>. Returns a new table.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
insertcolbefore(t, :x, :w, [0,1])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.map_rows-Tuple{Any,Vararg{Any,N} where N}" href="#IndexedTables.map_rows-Tuple{Any,Vararg{Any,N} where N}"><code>IndexedTables.map_rows</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">map_rows(f, c...)</code></pre><p>Transform collection <code>c</code> by applying <code>f</code> to each element. For multiple collection arguments, apply <code>f</code> elementwise. Collect output as <code>Columns</code> if <code>f</code> returns <code>Tuples</code> or <code>NamedTuples</code> with constant fields, as <code>Array</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-none">map_rows(i -&gt; (exp = exp(i), log = log(i)), 1:5)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.ncols" href="#IndexedTables.ncols"><code>IndexedTables.ncols</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ncols(itr)</code></pre><p>Returns the number of columns in <code>itr</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">ncols([1,2,3]) == 1
ncols(rows(([1,2,3],[4,5,6]))) == 2</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.ndsparse" href="#IndexedTables.ndsparse"><code>IndexedTables.ndsparse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ndsparse(keys, values; kw...)</code></pre><p>Construct an NDSparse array with the given <code>keys</code> and <code>values</code> columns. On construction, the keys and data are sorted in lexicographic order of the <code>keys</code>.</p><p><strong>Keyword Argument Options:</strong></p><ul><li><code>agg = nothing</code> – Function to aggregate values with duplicate keys.</li><li><code>presorted = false</code> – Are the key columns already sorted?</li><li><code>copy = true</code> – Should the columns in <code>keys</code> and <code>values</code> be copied?</li><li><code>chunks = nothing</code> – Provide an integer to distribute data into <code>chunks</code> chunks.<ul><li>A good choice is <code>nworkers()</code> (after <code>using Distributed</code>)</li><li>See also: <a href="@ref"><code>distribute</code></a></li></ul></li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">x = ndsparse([&quot;a&quot;,&quot;b&quot;], [3,4])
keys(x)
values(x)
x[&quot;a&quot;]

# Dimensions are named if constructed with a named tuple of columns
x = ndsparse((index = 1:10,), rand(10))
x[1]

# Multiple dimensions by passing a (named) tuple of columns
x = ndsparse((x = 1:10, y = 1:2:20), rand(10))
x[1, 1]

# Value columns can also have names via named tuples
x = ndsparse(1:10, (x=rand(10), y=rand(10)))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.pkeynames-Tuple{IndexedTables.AbstractIndexedTable}" href="#IndexedTables.pkeynames-Tuple{IndexedTables.AbstractIndexedTable}"><code>IndexedTables.pkeynames</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">pkeynames(t::Table)</code></pre><p>Names of the primary key columns in <code>t</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,2], [3,4]);
pkeynames(t)

t = table([1,2], [3,4], pkey=1);
pkeynames(t)

t = table([2,1],[1,3],[4,5], names=[:x,:y,:z], pkey=(1,2));
pkeynames(t)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.pkeynames-Tuple{NDSparse}" href="#IndexedTables.pkeynames-Tuple{NDSparse}"><code>IndexedTables.pkeynames</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">pkeynames(t::NDSparse)</code></pre><p>Names of the primary key columns in <code>t</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">x = ndsparse([1,2],[3,4])
pkeynames(x)

x = ndsparse((x=1:10, y=1:2:20), rand(10))
pkeynames(x)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.pkeys-Tuple{IndexedTable}" href="#IndexedTables.pkeys-Tuple{IndexedTable}"><code>IndexedTables.pkeys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">pkeys(itr::IndexedTable)</code></pre><p>Primary keys of the table. If Table doesn&#39;t have any designated primary key columns (constructed without <code>pkey</code> argument) then a default key of tuples <code>(1,):(n,)</code> is generated.</p><p><strong>Example</strong></p><pre><code class="language-none">a = table([&quot;a&quot;,&quot;b&quot;], [3,4]) # no pkey
pkeys(a)

a = table([&quot;a&quot;,&quot;b&quot;], [3,4], pkey=1)
pkeys(a)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.popcol-Tuple{Any,Vararg{Any,N} where N}" href="#IndexedTables.popcol-Tuple{Any,Vararg{Any,N} where N}"><code>IndexedTables.popcol</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">popcol(t, cols...)</code></pre><p>Remove the column(s) <code>cols</code> from the table. Returns a new table.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
popcol(t, :x)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.pushcol-Tuple{Any,Vararg{Any,N} where N}" href="#IndexedTables.pushcol-Tuple{Any,Vararg{Any,N} where N}"><code>IndexedTables.pushcol</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">pushcol(t, name, x)</code></pre><p>Push a column <code>x</code> to the end of the table. <code>name</code> is the name for the new column. Returns a new table.</p><pre><code class="language-none">pushcol(t, map::Pair...)</code></pre><p>Push many columns at a time.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
pushcol(t, :z, [1//2, 3//4])
pushcol(t, :z =&gt; [1//2, 3//4])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.reducedim_vec-Tuple{Any,NDSparse,Any}" href="#IndexedTables.reducedim_vec-Tuple{Any,NDSparse,Any}"><code>IndexedTables.reducedim_vec</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>reducedim_vec(f::Function, arr::NDSparse, dims)</code></p><p>Like <code>reduce</code>, except uses a function mapping a vector of values to a scalar instead of a 2-argument scalar function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.reindex" href="#IndexedTables.reindex"><code>IndexedTables.reindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">reindex(t::IndexedTable, by)
reindex(t::IndexedTable, by, select)</code></pre><p>Reindex table <code>t</code> with new primary key <code>by</code>, optionally keeping a subset of columns via <code>select</code>.  For <a href="#IndexedTables.NDSparse-Tuple"><code>NDSparse</code></a>, use <a href="#IndexedTables.selectkeys-Tuple{NDSparse,Any}"><code>selectkeys</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([2,1],[1,3],[4,5], names=[:x,:y,:z], pkey=(1,2))

t2 = reindex(t, (:y, :z))

pkeynames(t2)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.renamecol-Tuple{Any,Vararg{Any,N} where N}" href="#IndexedTables.renamecol-Tuple{Any,Vararg{Any,N} where N}"><code>IndexedTables.renamecol</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">renamecol(t, col, newname)</code></pre><p>Set <code>newname</code> as the new name for column <code>col</code> in <code>t</code>. Returns a new table.</p><pre><code class="language-none">renamecol(t, map::Pair...)</code></pre><p>Rename multiple columns at a time.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.01, 0.05], [2,1], names=[:t, :x])
renamecol(t, :t, :time)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.rows" href="#IndexedTables.rows"><code>IndexedTables.rows</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rows(itr, select = All())</code></pre><p>Select one or more fields from an iterable of rows as a vector of their values.  Refer to the <a href="#IndexedTables.select-Tuple{IndexedTables.AbstractIndexedTable,Any}"><code>select</code></a> function for selection options and syntax.</p><p><code>itr</code> can be <a href="#IndexedTables.NDSparse-Tuple"><code>NDSparse</code></a>, <code>StructArrays.StructVector</code>, <code>AbstractVector</code>, or their distributed counterparts.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,2],[3,4], names=[:x,:y])
rows(t)
rows(t, :x)
rows(t, (:x,))
rows(t, (:y, :x =&gt; -))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.select-Tuple{IndexedTables.AbstractIndexedTable,Any}" href="#IndexedTables.select-Tuple{IndexedTables.AbstractIndexedTable,Any}"><code>IndexedTables.select</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">select(t::Table, which::Selection)</code></pre><p>Select all or a subset of columns, or a single column from the table.</p><p><code>Selection</code> is a type union of many types that can select from a table. It can be:</p><ol><li><code>Integer</code> – returns the column at this position.</li><li><code>Symbol</code> – returns the column with this name.</li><li><code>Pair{Selection =&gt; Function}</code> – selects and maps a function over the selection, returns the result.</li><li><code>AbstractArray</code> – returns the array itself. This must be the same length as the table.</li><li><code>Tuple</code> of <code>Selection</code> – returns a table containing a column for every selector in the tuple.</li><li><code>Regex</code> – returns the columns with names that match the regular expression.</li><li><code>Type</code> – returns columns with elements of the given type.</li></ol><p><strong>Examples:</strong></p><pre><code class="language-none">t = table(1:10, randn(10), rand(Bool, 10); names = [:x, :y, :z])

# select the :x vector
select(t, 1)
select(t, :x)

# map a function to the :y vector
select(t, 2 =&gt; abs)
select(t, :y =&gt; x -&gt; x &gt; 0 ? x : -x)

# select the table of :x and :z
select(t, (:x, :z))
select(t, r&quot;(x|z)&quot;)

# map a function to the table of :x and :y
select(t, (:x, :y) =&gt; row -&gt; row[1] + row[2])
select(t, (1, :y) =&gt; row -&gt; row.x + row.y)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.selectkeys-Tuple{NDSparse,Any}" href="#IndexedTables.selectkeys-Tuple{NDSparse,Any}"><code>IndexedTables.selectkeys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">selectkeys(x::NDSparse, sel)</code></pre><p>Return an <code>NDSparse</code> with a subset of keys.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.selectvalues-Tuple{NDSparse,Any}" href="#IndexedTables.selectvalues-Tuple{NDSparse,Any}"><code>IndexedTables.selectvalues</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">selectvalues(x::NDSparse, sel)</code></pre><p>Return an <code>NDSparse</code> with a subset of values</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.setcol-Tuple{Any,Vararg{Any,N} where N}" href="#IndexedTables.setcol-Tuple{Any,Vararg{Any,N} where N}"><code>IndexedTables.setcol</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">setcol(t::Table, col::Union{Symbol, Int}, x::Selection)</code></pre><p>Sets a <code>x</code> as the column identified by <code>col</code>. Returns a new table.</p><pre><code class="language-none">setcol(t::Table, map::Pair{}...)</code></pre><p>Set many columns at a time.</p><p><strong>Examples:</strong></p><pre><code class="language-none">t = table([1,2], [3,4], names=[:x, :y])

# change second column to [5,6]
setcol(t, 2 =&gt; [5,6])
setcol(t, :y , :y =&gt; x -&gt; x + 2)

# add [5,6] as column :z
setcol(t, :z =&gt; 5:6)
setcol(t, :z, :y =&gt; x -&gt; x + 2)

# replacing the primary key results in a re-sorted copy
t = table([0.01, 0.05], [1,2], [3,4], names=[:t, :x, :y], pkey=:t)
t2 = setcol(t, :t, [0.1,0.05])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.stack-Union{Tuple{D}, Tuple{D}, Tuple{D,Any}} where D&lt;:Union{IndexedTable, NDSparse}" href="#IndexedTables.stack-Union{Tuple{D}, Tuple{D}, Tuple{D,Any}} where D&lt;:Union{IndexedTable, NDSparse}"><code>IndexedTables.stack</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">stack(t, by = pkeynames(t); select = Not(by), variable = :variable, value = :value)`</code></pre><p>Reshape a table from the wide to the long format. Columns in <code>by</code> are kept as indexing columns. Columns in <code>select</code> are stacked. In addition to the id columns, two additional columns labeled <code>variable</code> and <code>value</code> are added, containing the column identifier and the stacked columns. See also <a href="#IndexedTables.unstack-Union{Tuple{D}, Tuple{D}, Tuple{D,Any}} where D&lt;:Union{IndexedTable, NDSparse}"><code>unstack</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table(1:4, names = [:x], pkey=:x)
t = pushcol(t, :xsquare, :x =&gt; x -&gt; x^2)
t = pushcol(t, :xcube  , :x =&gt; x -&gt; x^3)

stack(t)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.summarize" href="#IndexedTables.summarize"><code>IndexedTables.summarize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">summarize(f, t, by = pkeynames(t); select = Not(by), stack = false, variable = :variable)</code></pre><p>Apply summary functions column-wise to a table. Return a <code>NamedTuple</code> in the non-grouped case and a table in the grouped case. Use <code>stack=true</code> to stack results of the same summary function for different columns.</p><p><strong>Examples</strong></p><pre><code class="language-none">using Statistics

t = table([1, 2, 3], [1, 1, 1], names = [:x, :y])

summarize((mean, std), t)
summarize((m = mean, s = std), t)
summarize(mean, t; stack=true)
summarize((mean, std), t; select = :y)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.table" href="#IndexedTables.table"><code>IndexedTables.table</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">table(cols; kw...)</code></pre><p>Create a table from a (named) tuple of AbstractVectors.</p><pre><code class="language-none">table(cols::AbstractVector...; names::Vector{Symbol}, kw...)</code></pre><p>Create a table from the provided <code>cols</code>, optionally with <code>names</code>.</p><pre><code class="language-none">table(cols::Columns; kw...)</code></pre><p>Construct a table from a vector of tuples. See <a href="#IndexedTables.rows"><code>rows</code></a> and <a href="@ref"><code>Columns</code></a>.</p><pre><code class="language-none">table(t::Union{IndexedTable, NDSparse}; kw...)</code></pre><p>Copy a Table or NDSparse to create a new table. The same primary keys as the input are used.</p><pre><code class="language-none">table(x; kw...)</code></pre><p>Create an <code>IndexedTable</code> from any object <code>x</code> that follows the <code>Tables.jl</code> interface.</p><p><strong>Keyword Argument Options:</strong></p><ul><li><code>pkey</code>: select columns to sort by and be the primary key.</li><li><code>presorted = false</code>: is the data pre-sorted by primary key columns?</li><li><code>copy = true</code>: creates a copy of the input vectors if <code>true</code>. Irrelevant if <code>chunks</code> is specified.</li><li><code>chunks::Integer</code>: distribute the table.  Options are:<ul><li><code>Int</code> – (number of chunks) a safe bet is <code>nworkers()</code> after <code>using Distributed</code>.</li><li><code>Vector{Int}</code> – Number of elements in each of the <code>length(chunks)</code> chunks.</li></ul></li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">table(rand(10), rand(10), names = [:x, :y], pkey = :x)

table(rand(Bool, 20), rand(20), rand(20), pkey = [1,2])

table((x = 1:10, y = randn(10)))

table([(1,2), (3,4)])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.unstack-Union{Tuple{D}, Tuple{D}, Tuple{D,Any}} where D&lt;:Union{IndexedTable, NDSparse}" href="#IndexedTables.unstack-Union{Tuple{D}, Tuple{D}, Tuple{D,Any}} where D&lt;:Union{IndexedTable, NDSparse}"><code>IndexedTables.unstack</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">unstack(t, by = pkeynames(t); variable = :variable, value = :value)</code></pre><p>Reshape a table from the long to the wide format. Columns in <code>by</code> are kept as indexing columns. Keyword arguments <code>variable</code> and <code>value</code> denote which column contains the column identifier and which the corresponding values.  See also <a href="#IndexedTables.stack-Union{Tuple{D}, Tuple{D}, Tuple{D,Any}} where D&lt;:Union{IndexedTable, NDSparse}"><code>stack</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table(1:4, [1, 4, 9, 16], [1, 8, 27, 64], names = [:x, :xsquare, :xcube], pkey = :x);

long = stack(t)

unstack(long)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.update!-Union{Tuple{N}, Tuple{Union{Function, Type},NDSparse,Vararg{Any,N}}} where N" href="#IndexedTables.update!-Union{Tuple{N}, Tuple{Union{Function, Type},NDSparse,Vararg{Any,N}}} where N"><code>IndexedTables.update!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>update!(f::Function, arr::NDSparse, indices...)</code></p><p>Replace data values <code>x</code> with <code>f(x)</code> at each location that matches the given indices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.where-Union{Tuple{N}, Tuple{NDSparse,Vararg{Any,N}}} where N" href="#IndexedTables.where-Union{Tuple{N}, Tuple{NDSparse,Vararg{Any,N}}} where N"><code>IndexedTables.where</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>where(arr::NDSparse, indices...)</code></p><p>Returns an iterator over data items where the given indices match. Accepts the same index arguments as <code>getindex</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.Perm" href="#IndexedTables.Perm"><code>IndexedTables.Perm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A permutation</p><p><strong>Fields:</strong></p><ul><li><code>columns</code>: The columns being indexed as a vector of integers (column numbers)</li><li><code>perm</code>: the permutation - an array or iterator which has the sorted permutation</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.broadcast-Tuple{Function,NDSparse,NDSparse}" href="#Base.Broadcast.broadcast-Tuple{Function,NDSparse,NDSparse}"><code>Base.Broadcast.broadcast</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">broadcast(f, A::NDSparse, B::NDSparse; dimmap::Tuple{Vararg{Int}})
A .* B</code></pre><p>Compute an inner join of <code>A</code> and <code>B</code> using function <code>f</code>, where the dimensions of <code>B</code> are a subset of the dimensions of <code>A</code>. Values from <code>B</code> are repeated over the extra dimensions.</p><p><code>dimmap</code> optionally specifies how dimensions of <code>A</code> correspond to dimensions of <code>B</code>. It is a tuple where <code>dimmap[i]==j</code> means the <code>i</code>th dimension of <code>A</code> matches the <code>j</code>th dimension of <code>B</code>. Extra dimensions that do not match any dimensions of <code>j</code> should have <code>dimmap[i]==0</code>.</p><p>If <code>dimmap</code> is not specified, it is determined automatically using index column names and types.</p><p><strong>Example</strong></p><pre><code class="language-none">a = ndsparse(([1,1,2,2], [1,2,1,2]), [1,2,3,4])
b = ndsparse([1,2], [1/1, 1/2])
broadcast(*, a, b)</code></pre><p><code>dimmap</code> maps dimensions that should be broadcasted:</p><pre><code class="language-none">broadcast(*, a, b, dimmap=(0,1))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{IndexedTable},Any,Any}" href="#Base.convert-Tuple{Type{IndexedTable},Any,Any}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(IndexedTable, pkeys, vals; kwargs...)</code></pre><p>Construct a table with <code>pkeys</code> as primary keys and <code>vals</code> as corresponding non-indexed items. keyword arguments will be forwarded to <a href="#IndexedTables.table"><code>table</code></a> constructor.</p><p><strong>Example</strong></p><pre><code class="language-none">convert(IndexedTable, Columns(x=[1,2],y=[3,4]), Columns(z=[1,2]), presorted=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.filter-Tuple{Any,Union{IndexedTable, NDSparse}}" href="#Base.filter-Tuple{Any,Union{IndexedTable, NDSparse}}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">filter(f, t::Union{IndexedTable, NDSparse}; select)</code></pre><p>Iterate over <code>t</code> and Return the rows for which <code>f(row)</code> returns true.  <code>select</code> determines  the rows that are given as arguments to <code>f</code> (see <a href="#IndexedTables.select-Tuple{IndexedTables.AbstractIndexedTable,Any}"><code>select</code></a>).</p><p><code>f</code> can also be a tuple of <code>column =&gt; function</code> pairs.  Returned rows will be those for which all conditions are true.</p><p><strong>Example</strong></p><pre><code class="language-none"># filter iterates over ROWS of a IndexedTable
t = table(rand(100), rand(100), rand(100), names = [:x, :y, :z])
filter(r -&gt; r.x + r.y + r.z &lt; 1, t)

# filter iterates over VALUES of an NDSparse
x = ndsparse(1:100, randn(100))
filter(val -&gt; val &gt; 0, x)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.join-Tuple{Any,Union{IndexedTable, NDSparse},Union{IndexedTable, NDSparse}}" href="#Base.join-Tuple{Any,Union{IndexedTable, NDSparse},Union{IndexedTable, NDSparse}}"><code>Base.join</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">join(left, right; kw...)
join(f, left, right; kw...)</code></pre><p>Join tables <code>left</code> and <code>right</code>.</p><p>If a function <code>f(leftrow, rightrow)</code> is provided, the returned table will have a single output column.  See the Examples below.</p><p>If the same key occurs multiple times in either table, each <code>left</code> row will get matched with each <code>right</code> row, resulting in <code>n_occurrences_left * n_occurrences_right</code> output rows.</p><p><strong>Options (keyword arguments)</strong></p><ul><li><code>how = :inner</code><ul><li>Join method to use. Described below.</li></ul></li><li><code>lkey = pkeys(left)</code><ul><li>Fields from <code>left</code> to match on (see <a href="#IndexedTables.pkeys-Tuple{IndexedTable}"><code>pkeys</code></a>).</li></ul></li><li><code>rkey = pkeys(right)</code><ul><li>Fields from <code>right</code> to match on.</li></ul></li><li><code>lselect = Not(lkey)</code><ul><li>Output columns from <code>left</code> (see <a href="#IndexedTables.Not"><code>Not</code></a>)</li></ul></li><li><code>rselect = Not(rkey)</code><ul><li>Output columns from <code>right</code>.</li></ul></li><li><code>missingtype = Missing</code><ul><li>Type of missing values that can be created through <code>:left</code> and <code>:outer</code> joins.</li><li>Other supported option is <code>DataValue</code>.</li></ul></li></ul><p><strong>Join methods (<code>how = :inner</code>)</strong></p><ul><li><code>:inner</code> – rows with matching keys in both tables</li><li><code>:left</code> – all rows from <code>left</code>, plus matched rows from <code>right</code> (missing values can occur)</li><li><code>:outer</code> – all rows from both tables (missing values can occur)</li><li><code>:anti</code> – rows in <code>left</code> WITHOUT matching keys in <code>right</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-none">a = table((x = 1:10,   y = rand(10)), pkey = :x)
b = table((x = 1:2:20, z = rand(10)), pkey = :x)

join(a, b; how = :inner)
join(a, b; how = :left)
join(a, b; how = :outer)
join(a, b; how = :anti)

join((l, r) -&gt; l.y + r.z, a, b)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.keys-Tuple{NDSparse,Vararg{Any,N} where N}" href="#Base.keys-Tuple{NDSparse,Vararg{Any,N} where N}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>keys(x::NDSparse[, select::Selection])</code></p><p>Get the keys of an <code>NDSparse</code> object. Same as <a href="#IndexedTables.rows"><code>rows</code></a> but acts only on the index columns of the <code>NDSparse</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map-Tuple{Any,IndexedTables.AbstractIndexedTable}" href="#Base.map-Tuple{Any,IndexedTables.AbstractIndexedTable}"><code>Base.map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">map(f, t::IndexedTable; select)</code></pre><p>Apply <code>f</code> to every item in <code>t</code> selected by <code>select</code> (see also the <a href="#IndexedTables.select-Tuple{IndexedTables.AbstractIndexedTable,Any}"><code>select</code></a> function).   Returns a new table if <code>f</code> returns a tuple or named tuple.  If not, returns a vector.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,2], [3,4], names=[:x, :y])

polar = map(p -&gt; (r = hypot(p.x, p.y), θ = atan(p.y, p.x)), t)

back2t = map(p -&gt; (x = p.r * cos(p.θ), y = p.r * sin(p.θ)), polar)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map-Tuple{Any,NDSparse}" href="#Base.map-Tuple{Any,NDSparse}"><code>Base.map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">map(f, x::NDSparse; select = values(x))</code></pre><p>Apply <code>f</code> to every value of <code>select</code> selected from <code>x</code> (see <a href="#IndexedTables.select-Tuple{IndexedTables.AbstractIndexedTable,Any}"><code>select</code></a>).</p><p>Apply <code>f</code> to every data value in <code>x</code>. <code>select</code> selects fields passed to <code>f</code>. By default, the data values are selected.</p><p>If the return value of <code>f</code> is a tuple or named tuple the result will contain many data columns.</p><p><strong>Examples</strong></p><pre><code class="language-none">x = ndsparse((t=[0.01, 0.05],), (x=[1,2], y=[3,4]))

polar = map(row -&gt; (r = hypot(row.x, row.y), θ = atan(row.y, row.x)), x)

back2x = map(row -&gt; (x = row.r * cos(row.θ), y = row.r * sin(row.θ)), polar)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.merge-Tuple{Union{IndexedTable, NDSparse},Any}" href="#Base.merge-Tuple{Union{IndexedTable, NDSparse},Any}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">merge(a::IndexedTable, b::IndexedTable; pkey)</code></pre><p>Merge rows of <code>a</code> with rows of <code>b</code> and remain ordered by the primary key(s).  <code>a</code> and <code>b</code> must have the same column names.</p><pre><code class="language-none">merge(a::NDSparse, a::NDSparse; agg)</code></pre><p>Merge rows of <code>a</code> with rows of <code>b</code>.  To keep unique keys, the value from <code>b</code> takes priority. A provided function <code>agg</code> will aggregate values from <code>a</code> and <code>b</code> that have the same key(s).</p><p><strong>Example:</strong></p><pre><code class="language-none">a = table((x = 1:5, y = rand(5)); pkey = :x)
b = table((x = 6:10, y = rand(5)); pkey = :x)
merge(a, b)

a = ndsparse([1,3,5], [1,2,3])
b = ndsparse([2,3,4], [4,5,6])
merge(a, b)
merge(a, b; agg = (x,y) -&gt; x)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pairs-Union{Tuple{N}, Tuple{NDSparse,Vararg{Any,N}}} where N" href="#Base.pairs-Union{Tuple{N}, Tuple{NDSparse,Vararg{Any,N}}} where N"><code>Base.pairs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>pairs(arr::NDSparse, indices...)</code></p><p>Similar to <code>where</code>, but returns an iterator giving <code>index=&gt;value</code> pairs. <code>index</code> will be a tuple.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reduce-Tuple{Any,IndexedTable}" href="#Base.reduce-Tuple{Any,IndexedTable}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">reduce(f, t::IndexedTable; select::Selection)</code></pre><p>Apply reducer function <code>f</code> pair-wise to the selection <code>select</code> in <code>t</code>.  The reducer <code>f</code> can be:</p><ol><li>A function</li><li>An OnlineStat</li><li>A (named) tuple of functions and/or OnlineStats</li><li>A (named) tuple of (selector =&gt; function) or (selector =&gt; OnlineStat) pairs</li></ol><p><strong>Examples</strong></p><pre><code class="language-none">t = table(1:5, 6:10, names = [:t, :x])

reduce(+, t, select = :t)
reduce((a, b) -&gt; (t = a.t + b.t, x = a.x + b.x), t)

using OnlineStats
reduce(Mean(), t, select = :t)
reduce((Mean(), Variance()), t, select = :t)

y = reduce((min, max), t, select=:x)
reduce((sum = +, prod = *), t, select=:x)

# combining reduction and selection
reduce((xsum = :x =&gt; +, negtsum = (:t =&gt; -) =&gt; +), t)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reduce-Tuple{Any,NDSparse}" href="#Base.reduce-Tuple{Any,NDSparse}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">reduce(f, x::NDSparse; dims)</code></pre><p>Drop the <code>dims</code> dimension(s) and aggregate values with <code>f</code>.</p><pre><code class="language-none">x = ndsparse((x=[1,1,1,2,2,2],
              y=[1,2,2,1,2,2],
              z=[1,1,2,1,1,2]), [1,2,3,4,5,6])

reduce(+, x; dims=1)
reduce(+, x; dims=(1,3))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sort!-Tuple{IndexedTable,Vararg{Any,N} where N}" href="#Base.sort!-Tuple{IndexedTable,Vararg{Any,N} where N}"><code>Base.sort!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sort!(t    ; kw...)
sort!(t, by; kw...)</code></pre><p>Sort rows of <code>t</code> by <code>by</code> in place. All of <code>Base.sort</code> keyword arguments can be used.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,1,1,2,2,2], [1,1,2,2,1,1], [1,2,3,4,5,6], names=[:x,:y,:z]);
sort!(t, :z, rev = true)
t</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sort-Tuple{IndexedTable,Vararg{Any,N} where N}" href="#Base.sort-Tuple{IndexedTable,Vararg{Any,N} where N}"><code>Base.sort</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sort(t    ; select, kw...)
sort(t, by; select, kw...)</code></pre><p>Sort rows by <code>by</code>. All of <code>Base.sort</code> keyword arguments can be used.</p><p><strong>Examples</strong></p><pre><code class="language-none">t=table([1,1,1,2,2,2], [1,1,2,2,1,1], [1,2,3,4,5,6],
sort(t, :z; select = (:y, :z), rev = true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.values-Tuple{NDSparse,Vararg{Any,N} where N}" href="#Base.values-Tuple{NDSparse,Vararg{Any,N} where N}"><code>Base.values</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>values(x::NDSparse[, select::Selection])</code></p><p>Get the values of an <code>NDSparse</code> object. Same as <a href="#IndexedTables.rows"><code>rows</code></a> but acts only on the value columns of the <code>NDSparse</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.arrayof-Tuple{Any}" href="#IndexedTables.arrayof-Tuple{Any}"><code>IndexedTables.arrayof</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">arrayof(T)</code></pre><p>Returns the type of <code>Columns</code> or <code>Vector</code> suitable to store values of type T. Nested tuples beget nested Columns.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.best_perm_estimate-Tuple{Any,Any}" href="#IndexedTables.best_perm_estimate-Tuple{Any,Any}"><code>IndexedTables.best_perm_estimate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns: (n, perm) where n is the number of columns in the beginning of <code>cols</code>, <code>perm</code> is one possible permutation of those first <code>n</code> columns.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.convertmissing-Tuple{IndexedTable,Type{Missing}}" href="#IndexedTables.convertmissing-Tuple{IndexedTable,Type{Missing}}"><code>IndexedTables.convertmissing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convertmissing(tbl, missingtype)</code></pre><p>Convert the missing value representation in <code>tbl</code> to be of type <code>missingtype</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">using IndexedTables, DataValues
t = table([1,2,missing], [1,missing,3])
IndexedTables.convertmissing(t, DataValue)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.excludecols-Tuple{Any,Any}" href="#IndexedTables.excludecols-Tuple{Any,Any}"><code>IndexedTables.excludecols</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">excludecols(itr, cols) -&gt; Tuple of Int</code></pre><p>Names of all columns in <code>itr</code> except <code>cols</code>. <code>itr</code> can be any of <code>IndexedTable</code>, <code>NDSparse</code>, <code>StructArrays.StructVector</code>, or <code>AbstractVector</code></p><p><strong>Examples</strong></p><pre><code class="language-none">using IndexedTables: excludecols

t = table([2,1],[1,3],[4,5], names=[:x,:y,:z], pkey=(1,2))

excludecols(t, (:x,))
excludecols(t, (2,))
excludecols(t, pkeynames(t))
excludecols([1,2,3], (1,))</code></pre></div></div></section><footer><hr/><a class="previous" href="../tutorial/"><span class="direction">Previous</span><span class="title">Tutorial</span></a></footer></article></body></html>
